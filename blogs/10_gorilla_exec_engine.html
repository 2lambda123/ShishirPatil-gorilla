<!DOCTYPE html>
<html>

<head>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-NRZJLJCSH6"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-NRZJLJCSH6');
    </script>


    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gorilla Execution Engine</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.5.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro">
    <link rel="stylesheet" href="../assets/css/styles.css">
</head>

<body>
    <!-- Navigation Bar -->
    <div class="navbar" style="position: absolute; top: 0; right: 20px; padding: 10px; z-index: 100; font-size: 18px;">
        <a href="/index.html">Home</a>
        <a href="/blog.html">Blogs</a>
        <a href="/leaderboard.html">Leaderboard</a>
        <a href="/apizoo/">API Zoo Index</a>
    </div>
    <div class="highlight-clean-blog" style="padding-bottom: 10px;">
        <h1 class="text-center" style="padding-bottom: 10px;"> ü¶ç GoEX: A Runtime for Autonomous LLM Applications</h1>

        <div class="blog-container">
            <div class="blog-post">
                <div class="author-date">
                    <p class="author"> <a href="https://shishirpatil.github.io/">Shishir G. Patil</a></p>
                    <p class="author"> <a href="https://tianjunz.github.io/">Tianjun Zhang</a></p>
                    <p class="author"> <a href="https://www.vivi.sh/">Vivian Fang</a></p>
                    <p class="author"> <a href="https://www.linkedin.com/in/noppapon/">Noppapon C.</a></p>
                    <p class="author"> <a href="https://www.linkedin.com/in/royh021/">Roy Huang</a></p>
                    <p class="author"> <a href="https://www.linkedin.com/in/aaron-hao/">Aaron Hao</a></p>
                </div>
                <div class="author-date">
                    <p class="author"> <a href="https://www.linkedin.com/in/martincasado/">Martin Casado</a></p>
                    <p class="author"> <a href="https://people.eecs.berkeley.edu/~jegonzal/">Joseph E. Gonzalez</a></p>
                    <p class="author"> <a href="https://people.eecs.berkeley.edu/~raluca/">Raluca Ada Popa</a></p>
                    <p class="author"> <a href="https://people.eecs.berkeley.edu/~istoica/">Ion Stoica</a></p>
                </div>

                <div class ="author-date">
                    <p class="date">
                        shishirpatil@berkeley.edu, tianjunz@berkeley.edu
                    </p> 
                </div>

                <!-- <div class ="author-date">
                    <p class="date">Apr 9, 2024</p>
                </div> -->



                <div class="Introduction">
                    <p>
                        Large Language Models (LLMs) are evolving beyond their role of providing information within dialogue systems to 
                        actively engaging with tools and performing actions on real-world applications and services. Today, humans 
                        verify the correctness and appropriateness of the LLM-generated outputs (e.g., code, functions, or actions) 
                        before putting them into real-world execution. 
                        This poses significant challenges as code comprehension is well known to be notoriously difficult. 
                        In this paper, we study how humans can efficiently collaborate with, delegate to, and supervise autonomous LLMs in the future. 
                        We argue that in many cases, ‚Äúpost-facto validation‚Äù‚Äîverifying the correctness of a proposed action after seeing the 
                        output‚Äîis much easier than the aforementioned ‚Äúpre-facto validation‚Äù setting. The core concept behind enabling a post-facto
                        validation system is the integration of an intuitive undo feature, and establishing a damage confinement for
                        the LLM-generated actions as effective strategies to mitigate the associated risks. Using this, a human can
                        now either revert the effect of an LLM-generated output or be confident that the potential risk is bounded.
                        We believe this is critical to unlock the potential for LLM agents to interact with applications and services
                        with limited (post-facto) human involvement. We describe the design and implementation of our open-source
                        runtime for executing LLM actions, Gorilla Execution Engine (GoEx), and present open research questions
                        towards realizing the goal of LLMs and applications interacting with each other with minimal human super-
                        vision. 
                        The Exec Engine is completely open source, under Apache 2.0 license. 
                    </p>
                    <p>
                        Quick Links:
                        <li>
                            Paper: <a href="https://arxiv.org/abs/2404.06921">https://arxiv.org/abs/2404.06921</a>
                        </li>
                        <li>
                            Github: <a href="https://github.com/ShishirPatil/gorilla">https://github.com/ShishirPatil/gorilla</a>
                        </li>
                    </p>
                </div>
                

                <div class="body">
                    <ol type="I">
                        <h4>
                            <li> GoEx Slack Demo ü§ñ
                        </h4>

                        Let's first take a look at a demo of GoEx in action. In this example, Vivian uses GoEx to send a message "Hello Tianjun, it's nice to meet you! Let's get you setup..." to the a Tianjun in Slack. The user can choose to either commit or undo the action if the generated code is incorrect.

                        <img src="../assets/img/blog_10/blog_post_10_demo.gif" alt="GoEX Slack Demo" style="width: 100%;">
                        <p width="80%" style="text-align:center; margin-left:10%; margin-right:10%; padding-bottom: -10px">
                            <i style="font-size: 0.9em;">
                                GoEx provides a simple and intuitive interface for executing LLM generated code, with the option to commit or undo the action.
                            </i>
                        </p>

                        <h4>
                            <li> Moving from Chatbots to Autonomous Agents üöÄ
                        </h4>
                        <p>
                            In the example above, the LLM is autonomously empowering microservices, services, and applications, with little human supervision. Broadening the scope, different applications can be built on top of the GoEx engine, such as a Slack bot that can autonomously send messages, a Spotify bot that can autonomously create playlists, or a Dropbox bot that can autonomously create folders.
                        </p>
                        <p>
                            The 
                        </p>

                        <img src="..\assets\img\blog_10\goex_intro_image.png" alt="How to Use Gorilla Image"
                            style="width: 70%;">
                        <p width="80%" style="text-align:center;padding-bottom: -10px">
                            <i style="font-size: 0.9em;">
                                GoEx offers a new way to interface with LLMs, providing abstractions for authorization, execution, and error handling.
                            </i>
                        </p>

                        <ol>
                            <li><b>Post-Facto Validation:</b>
                                <br>
                                <ul>
                                    In the context of API calls, it is often easier to verify the correctness of the call by 
                                    analyzing its result, rather than the process. Take this example:
                                </ul>
                                
                                <ul>
                                    This code was generated with the prompt: "Send a message to my most recently used Slack channel." 
                                    At first glance, it's hard to tell whether the generated code is correct or not. Upon running it, the code
                                    instead sends the message to the first slack channel returned by Slack. Unfortunately for our developers, this one happened
                                    to ping everyone in Sky Lab's general channel.
                                </ul>
                                <ul>
                                    Regardless, it often easier to find mistakes after execution, motivating the following paradigm. 
                                </ul>
                            </li>
                            <li> <b>Reversibility/ Undo Command:</b>
                                <br>
                                <ul>
                                    In order to be able to rectify mistakes made by the LLM, we propose having a
                                    generated ‚Äúundo‚Äù function. If an API call changes some state, then most likely
                                    there will be another API call that undoes that action. We choose to undo erroneous 
                                    actions rather than just mitigating them.
                                </ul>
                            </li>
                            <li> <b>Blast Radius</b>
                                <ul>
                                    Blast radius is another term we define as the scope of what the LLM can do. 
                                    It provides an upper bound on the amount of damage that an LLM could do. One 
                                    way that we reduce the blast radius of LLMs is to only provide the relevant 
                                    credentials during each execution. If I‚Äôm trying to create a new playlist on 
                                    Spotify, the LLM should not have access to my Gmail credentials. In this way, 
                                    we mitigate the risks of running unverified code. Another form of blast radius 
                                    control comes in the form of OAuth scopes. OAuth services attach certain permissions 
                                    to each generated token. For instance, I want to be able to read my files on Dropbox, 
                                    I don‚Äôt need write access. During authentication, this scope is specified, and attached 
                                    to the generated authentication token. 
                                </ul>
                            </li>
                            <li><b>Credential Security</b>
                                <ul>
                                    When we pass in input to the LLM, we want to avoid giving it sensitive information as 
                                    much as possible. Many consumers would not feel comfortable providing secret keys to an LLM.
                                    There are many ways to rectify this, for instance, giving LLM dummy keys or placeholder text 
                                    to use. In Gorilla Exec Engine, we store credentials in the local file system. We then provide 
                                    the file path to the object to the LLM so it can indirectly use them. In this way, none of the 
                                    sensitive information is leaked to the model, but they are still usable during execution.  
                                </ul>
                            </li>
                        </ol>
                        </p>
                        </li>
                        <h4>
                            <li> GoEx CLI üñ•Ô∏è
                        </h4>
                        <p>
                            <i>
                                Check out the repo 
                                <a href="https://github.com/ShishirPatil/gorilla/tree/main/exec-engine">
                                    here at github.
                                </a>
                                Let us know what you think!
                            </i>
                            <br>
                        <p>
                            The Gorilla CLI is an easy to use demo of the gorilla engine, 
                            right in your terminal. It has functionality for RESTful, database, 
                            filesystem calls. Here are the three types of APIs it supports:
                        </p>
                        <ol>
                            <li>RESTful</li>
                            <li>Database</li>
                            <li>Filesystem</li>
                        </ol>
                        </p>
                        <p>
                            The CLI can be easily installed through pip. For more information on installation and execution check out the repo. 
                        </p>

                        <img src="..\assets\img\blog_10\simple_overview.png" alt="How to Use Gorilla Image"
                        style="width: 60%;">
                        <h5>
                            RESTful API Calls: 
                        </h5>
                        <p>
                            Specify a natural language request and we will automatically provide credentials to execute 
                            a RestAPI call. Some services OAuth services we current support include the following: 
                        </p>
                        <ul>
                            <li>Gmail</li>
                            <li>Slack</li>
                            <li>Dropbox</li>
                            <li>Github</li>
                            <li>Spotify<i> (Awaiting Approval)</i></li>
                        </ul>
                        <br>
                        <p>
                            We provide two different ways to authenticate:
                        </p>
                        <ol>
                            <li>
                                <b>OAuth Authentication:</b> Simply specify a service, and we will open a browser for you to 
                                sign and provide credentials. These credentials are stored in your local filesystem, 
                                and are not recorded by us. 
                            </li>
                            <li>
                                <b>API Key:</b> Add in raw API keys directly in the terminal, and they will be saved in local files for future use.
                            </li>
                        </ol>
                        <br>
                        <p>
                            In both cases, credentials are automatically retrieved based on the given prompt. Only the 
                            relevant credentials are provided for each individual prompt, limiting the risk of execution.
                        </p>
                        <p>
                            After execution, we display the code output for you to verify. The LLM is also prompted to provide 
                            a reverse call, which can be selected after the forward call. Not all API calls are reversible, 
                            though in all cases the LLM is prompted to make an attempt at generating one. To call the reverse 
                            call, simply select the reverse option in the terminal.
                        </p>
                        
                        <h5>Function Calling</h5>
                        <p>
                            For some RESTful calls we offer the option of generating API calls with Function Calling. 
                            This feature allows the user to predefine functions that are guaranteed to work, and have the LLM 
                            be prompted using them to increase success rate. Currently only a limited number of Slack functions 
                            are available. Users can enable this by specifying <code>-generate_mode function_in_context</code>.
                        </p>
                        <p>
                            There are two different ways to use function calling:
                        </p>
                        <ol>
                            <li>
                                <b>Function In Context: </b>This mode feeds in the code of each function as input to the LLM, 
                                which then chooses the right executable call with the correct arguments. 
                            </li>
                            <li>
                                <b>Function Calling Native: </b> Native function calling relies on existing OpenAI function calling: 
                                providing a description of the set of usable functions, and receiving an executable call. 
                                See <a href=https://platform.openai.com/docs/guides/function-calling>OpenAI Function Calling</a> for more details. 
                            </li>
                        </ol>
                        <br>
                        <h5>
                            Databases (CLI Only) 
                        </h5>
                        <p>
                            With databases, all you need to do is to provide your database connection config and the engine 
                            will handle the rest. We currently support MySQL and SQLite, and will add support for other DBs 
                            down the line. 
                        </p>
                        <p>
                            We support a large number of operations, including but not limited to: insertion, deletion, table 
                            creation, modifications and more. Here is a video demonstrating how it works with the CLI:
                        </p>
                        <div class="responsive-iframe-container" style="text-align: center;">
                            <iframe src="https://www.youtube.com/embed/oW5aww589nE?si=BxcW64itZ3Je15N_"  frameborder="0"
                                style="width: 70%; height: 400px;"
                                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                                allowfullscreen>
                            </iframe>
                        </div>
                        <h5>Steps</h5>
                        <ol>
                            <li>
                                Provide the database access configurations (MySQL login + host or SQLite3 DB Path) and  specify the database you wish to use. We have a script for you to do this hassle-free!
                            </li>
                            <li>
                                Ask your question. The following is an example:
                                <br>
                                <code>
                                    goex execute -prompt "Create a new table for storing user information called users, with each user having a current balance column denoting their bank balance" -type db
                                </code>
                            </li>
                            <li>
                                GoEx executes and asks you for confirmation (Commit/Undo)
                            </li>
                        </ol>
                        <br>    
                        <p>
                        Super simple and straightforward flow! More details here in the <a href= "https://github.com/ShishirPatil/gorilla/tree/main/exec-engine?tab=readme-ov-file#database">repo.</a>
                        </p>
                        <p>
                            The database works with two options:
                        </p>
                        
                        <h5>
                            Filesystem (CLI Only)
                        </h5>
                        <p>
                            With filesystems, all you need to do is to enter a directory path at which you want GoEx to execute in, 
                            and the engine will handle the rest. We currently support only Unix file system commands, and will add 
                            support for other command types down the line. 
                        </p>
                        <p>
                            We support almost every common file-related operation, and rest assured that the execution will only take 
                            place within the specified directory, so the rest of your filesystem is safe!
                        </p>
                        <div class="responsive-iframe-container" style="text-align: center;">
                            <iframe src="https://www.youtube.com/embed/vLlVpdelz0U?si=1HBb-GFgsMeBcIra"  frameborder="0"
                                style="width: 70%; height: 400px;"
                                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                                allowfullscreen>
                            </iframe>
                        </div>    
                        <h5>Steps</h5>
                        <ol>
                            <li>
                                Provide the directory path. We have a script for you to do this hassle-free!
                            </li>
                            <li>
                                Ask your question. The following is an example:
                                <br>
                                <code>
                                    goex execute -prompt "Write a witty LLM joke into joke.txt" -type fs
                                </code>
                            </li>
                            <li>
                                GoEx executes and asks you for confirmation (Commit/Undo)
                            </li>
                        </ol>
                        <br>`
                        <p>
                            Another super simple and straightforward flow! More details here in the <a href= "https://github.com/ShishirPatil/gorilla/tree/main/exec-engine?tab=readme-ov-file#filesystem">repo.</a>
                        </p>
                        <br>
                        <h4>
                            <li>Slack Example Walkthrough 
                        </h4>
                        To get yourself started with GoEx, follow along with this example. This example requires a slack account. We will be walking through the process of sending a message to someone on slack.

                        <ol>
                            <li>
                                <b>Enviroment Setup and Installation:</b> 
                                <p>
                                    We highly recommend using a new enviroment for GoEx. We will use conda for this example. <br>
                                    <code>conda create --name goex python=3.10 -y</code><br>
                                    <code>conda activate goex</code><br>
                                </p>
                                <p>
                                    We then install goex using the following command in the exec-engine folder. You will need to clone from the Gorilla repository. <br>
                                    <code>pip install -e .</code><br>
                                </p>
                                <p>
                                    We use Mkcert to support OAuth2 token exchange. This is necessary for all OAuth services.<br>
                                    <code>brew install mkcert</code><br>
                                    <code>mkcert -install</code><br>
                                    <code>mkcert localhost</code><br>
                                    <i>Windows users can use choco to install mkcert</i>
                                </p>
                            </li>
                            <li>
                                <b>Slack Authorization:</b> 
                                <p>
                                    To authorize for slack use the following command:<br>
                                    <code>goex -authorize slack</code>
                                </p>
                                This will open a window in your browser that prompts you to sign in. The link should also be printed in the terminal like this:
                                <img src="..\assets\img\blog_10\slack_auth_terminal.png" alt=""
                                style="width: 100%;"><br>
                                You will be asked to give GoEx permission to a workspace of your choice. Something like this should show up:
                                <img src="..\assets\img\blog_10\slack_request_screen.png" alt=""
                                style="width: 100%;">
                            </li>
                            <li>
                                <b>Execute with GoEx!</b>
                                <p>
                                    To execute prompts with goex, specify the server in your prompt, and add the type of execution. 
                                    <i>(rest, db, fs)</i>. Feel free to play around with the prompt.  <b>Make sure to have docker desktop running in the background.</b><br>
                                    <code>goex execute -prompt send a funny joke to the user with email gorilla@yahoo.com on slack -type rest</code><br>
                                </p>
                                <p>
                                    Hopefully, after running you should see your new message:
                                    <img src="..\assets\img\blog_10\slack_message_result.png" alt=""
                                    style="width: 100%;">
                                </p>

                                <p>
                                    Your output should look something like this:
                                    <img src="..\assets\img\blog_10\slack_commit_undo.png" alt=""
                                    style="width: 100%;">
                                </p>
                                <p>
                                    To unsend the message, select the undo option with the keyboard arrows and hit enter. 
                                </p>
                                <p>
                                    If you're having trouble sending a message with email, try using the slack channel ID or slack handle. 
                                </p>
                            </li>
                        </ol>
                        
                        Congratulations! You've succesfully sent a message using the power of LLMs!
                        <h4>
                            <li>GoEx Web-App
                        </h4>
                        <p>
                            Another option to check out the exec engine would be the web-app, hosted <a href= "https://goex.gorilla-llm.com/">here.</a> 
                            Currently, the web-app supports only RESTful calls. The web-app displays generated LLM code, allowing users not only to see, 
                            but to edit the model output. Then, users can decide whether to run the forward or reverse call and view the output. 
                            To save your queries for later, we provide the ability to log in with Google, automatically saving all content. 
                        </p>
                        <div class="responsive-iframe-container" style="text-align: center;">
                            <iframe src="https://www.youtube.com/embed/CBxaGsqJPkQ?si=JAbA8HoGSo3Hs1cz" frameborder="0"
                                style="width: 70%; height: 400px;"
                                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                                allowfullscreen>
                            </iframe>
                        </div>
                        <p class="text-center">
                            <i>Explore GoEx without any installation using the GoEx Web-App</i>
                        </p>
                        <p>
                            Currently the web app does not support all security functionality that the Gorilla CLI provides. Notably, the CLI does not 
                            expose API keys to the LLM model, instead passing in a file path to retrieve sensitive information. This is not possible 
                            on a web browser, and so the queries generated using the front end involve passing raw credentials to the LLM model.
                        </p>
                        <p>
                            In the web-app, all sensitive credentials are stored in browser local storage, then retrieved when necessary to execute. 
                            Our decision to store this data in local storage was motivated by a desire to provide security assurances to the user. 
                            We do not store any sensitive information on our servers. Currently, authentication can come in the form of OAuth 
                            credentials as well as raw API keys. The number of OAuth services we provide are limited to the ones we add support for, 
                            but any number of raw API keys can be added in the browser for different services. 
                        </p>

                        <h4><li>Summary</h4>
                        <p>
                            In the evolution of LLMs from chatbots to empowering services and applications, slowly moving
                            away from passively providing information to actively and autonomously making decisions has
                            become an increasing trend. We introduce the concept of post-facto validation 
                            as a execution paradigm for these new system. We present GoEx as a means to this vision, a critical
                            step toward an LLM tool usage capabilities. 
                            <br>
                            Be sure to check out our <a href="https://discord.gg/grXXvj9Whz">Discord community</a> for
                            updates and any questions as well as our <a
                                href="https://github.com/ShishirPatil/gorilla">official repo</a> on Github.
                        </p>
                        <h4><li>Citations</h4>
                        <pre
                            style="white-space: pre-wrap; width: 100%; overflow-x: auto; background-color: #f4f4f4; color: #333;">
                            <code>
    @inproceedings{gorilla-exec-engine,
        title={Gorilla Exec Engine},
        author={Shishir G. Patil, Tianjun Zhang, Vivian Fang, Noppapon C., Roy Huang, Aaron Hao, Martin Casado, Joseph E. Gonzalez, Raluca Ada Popa, Ion Stoica},
        year={2024},
        howpublished={\url{https://gorilla.cs.berkeley.edu//blogs/10_gorilla_exec_engine.html}},
    }                   </code>
                        </pre>
                    </ol>
                </div>
            </div>
        </div>
    </div>

    <style>
        body {
            font-family: 'Source Sans Pro', sans-serif;
            margin: 0;
            padding: 0;
            background: white;
            justify-content: center;
            align-items: center;
        }

        .blog-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .blog-post {
            padding: 20px;
            max-width: 70%;
            justify-content: center;
        }
        
        @media only screen and (max-width: 768px) {
            .blog-post {
                max-width: 100%;
            }
        }

        .blog-post img {
            display: block;
            margin: 0 auto;
        }

        .blog-title {
            color: #055ada;
            text-align: center;
        }

        .author-date {
            display: flex;
            margin-bottom: 0px;
            justify-content: center;
        }

        .author {
            font-size: 16px;
            color: #1E90FF;
            margin-right: 20px;
        }

        .date {
            font-size: 16px;
            color: #7e8790;
        }

        .preview {
            text-align: justify;
            text-justify: inter-word;
        }

        .highlight-clean-blog {
            color: #313437;
            background-color: #fff;
            padding: 50px 0;
        }

        .box-index {
            position: fixed;
            top: 50%;
            left: 0px;
            transform: translateY(-50%);
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            max-width: 150px;
        }

        .box-index h3 {
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .box-index ul {
            list-style-type: disc;
            padding: 0;
        }

        .box-index ul li {
            margin-bottom: 10px;
        }

        .box-index ul li a {
            text-decoration: none;
            color: #333;
        }

        .box-index ul li a:hover {
            color: #1E90FF;
        }


        .more-blogs .sub-menu {
            display: none;
        }

        .more-blogs .sub-menu.expanded {
            display: block;
            max-height: 200px;
            /* Adjust the max height as needed */
            overflow-y: auto;
        }

        .more-blogs .sub-menu li {
            padding: 10px;
            border-bottom: 1px solid #ccc;
        }

        .more-blogs .sub-menu li:last-child {
            border-bottom: none;
        }

        .more-blogs .caret {
            transition: transform 0.3s ease-in-out;
            display: inline-block;
            transform: rotate(0deg);
            font-size: 12px;
            /* Adjust the font size to change the caret size */
        }

        .more-blogs.expanded .caret {
            transform: rotate(90deg);
        }

        @media screen and (max-width: 768px) {
            .blog-post {
                padding: 10px;
                /* Adjust spacing for smaller screens */
            }

            .blog-post img {
                max-width: 80%;
                /* Reduce image size for smaller screens */
            }

            .box-index {
                display: none;
                /* Hide the index on smaller screens */
            }
        }

        .container {
            max-width: 100%;
            width: auto;
        }


        @media (max-width: 768px) {
            h1 {
                font-size: 24px; 
            }

            h2 {
                font-size: 18px;
            }
        }

    </style>
</body>

</html>

<script>
    function toggleMoreBlogs() {
        var subMenu = document.querySelector('.more-blogs .sub-menu');
        var parentItem = document.querySelector('.more-blogs');
        subMenu.classList.toggle('expanded');
        parentItem.classList.toggle('expanded');
    }
</script>